# 1. What are primitives? How can developers use them?
Примитивные данные это числа, строки и логические значения (правда или ложь). 

Я бы определила их как данные, чья структура задается естественно, во внешнем мире, они используются в той форме, в которой  они появились. 

Но сказать, что в коде они используются совсем непреобразованными, нельзя, дело в том, у каждого из них есть глобальный объект, созданный программно, в котором заданы методы работы с конкретным примитивом. При вызове метода, JS “оборачивает” примитив в объект, и только так может этот метод работать с конкретным значением.

# 2. What does keyword `this` mean?
“this” это ссылка на контекст, скорее всего к объекту, внутри которого вызывается метод с использованиям this. Важно понимать, что при этом не имеет значения, где этот метод был создан, контекст это именно место вызова.

# 3. What are callbacks?
Call-back функция это то с помощью чего можно вернуть значение асинхронной функции. Так как асинхронная функция не обязательно начнет выполняться в момент вызова, а в неизвестный момент времени, то и результат ее вернет функция, которая вызовется только в момент окончания операции.

# 4. What is a function declaration and how are its types different?
Функции это объект с какой-либо логикой обработки передаваемых данных, причем данные передавать необязательно, ключевым здесь является именно какое-то действие внутри функции.

Создать функцию можно с использованием конструктора Function. Особенностью здесь будет то, что при вызове такая функция сможет оперировать только теми данными, которые определены в области видимости вызова, а не там, где она была объявлена. Можно объявлять функцию с помощью конструкции new Function или просто Function. Аналогичным методом можно объявлять функцию через использование инструкции function.

Немного отличаются от обычных функций так называемые функциональные выражения, не столько синтаксисом,  хотя функциональные сообщения чаще бывают безымянными или анонимными, сколько случаями применения - функциональные выражения используются для определения функции внутри выражения и анонимными бывают потому что как правило вызываются одновременно с заданием. Существенной разницей между функциями и функциональными выражением я бы назвала только то, что функции мы можем использовать до ее объявления, так как ее объявление “поднимает” ее определение. 

Ну и наконец стрелочные функции. Основное отличие от обычной функции в упрощенном синтаксисе и в лексической привязке к своему this. То есть она как раз оперирует теми данными которые есть там, где она создана, а не там где она вызвана. Поэтому this внутри такой функции работает не так как ожидается.

# 5. Compare spread and rest operators.
rest оператор прекрасен при реструктуризации массива, он позволяет разбить его на условно “первый, второй и остальные” или “первый и остальные”. Иными словами позволяет выделить необходимое количество элементов в начале массива и не потерять остальные. 

Это удобно например когда мы каким-то образом обрабатываем элементы массива и на каждом цикле убираем обработанный первый и дальше используем оставшиеся, растягивая их как раз с помощью spread оператора, который выполняет ровно противоположную функцию - “раскрывает” массив, вытаскивая из него элементы и поднимая их на уровень с остальными элементами массива. 

Оба оператора выглядят одинаково, но rest используется только в конце массива, а spread где угодно как раз в силу специфики своих назначений. Еще можно сказать, что rest чаще находится слева от знака равно, а spread справа.